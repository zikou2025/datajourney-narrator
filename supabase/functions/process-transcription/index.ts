import { serve } from "https://deno.land/std@0.168.0/http/server.ts"
import "https://deno.land/x/xhr@0.1.0/mod.ts"

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
}

interface LogEntry {
  id?: string;
  timestamp?: string;
  location: string;
  activityCategory: string;
  activityType: string;
  equipment: string;
  personnel: string;
  material: string;
  measurement: string;
  status?: "completed" | "in-progress" | "planned" | "delayed" | "cancelled";
  notes: string;
  media?: string;
  referenceId?: string;
  coordinates?: [number, number];
}

// Cache AI results for efficiency and cost reduction
const aiResultCache = new Map<string, LogEntry[]>();

serve(async (req) => {
  // Handle CORS preflight requests
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders })
  }

  try {
    const { text, preferredProcessor } = await req.json()
    
    if (!text) {
      throw new Error('Transcription text is required')
    }

    // Generate a simple hash of the text for caching
    const textHash = await generateSimpleHash(text);
    
    // Check cache first
    if (aiResultCache.has(textHash)) {
      console.log('Using cached results for this transcription')
      return new Response(
        JSON.stringify({ logs: aiResultCache.get(textHash), fromCache: true }),
        { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      )
    }

    // Process the transcription with enhanced analysis
    const logs = await processTranscriptionWithAI(text, preferredProcessor)
    
    // Cache the results
    aiResultCache.set(textHash, logs);
    
    // If cache gets too large, clear old entries
    if (aiResultCache.size > 100) {
      const oldestKey = aiResultCache.keys().next().value;
      aiResultCache.delete(oldestKey);
    }

    return new Response(
      JSON.stringify({ logs, fromCache: false }),
      { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    )

  } catch (error) {
    console.error('Error processing transcription:', error)
    return new Response(
      JSON.stringify({ error: error.message }),
      {
        status: 400,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      }
    )
  }
})

// Generate a simple hash for caching
async function generateSimpleHash(text: string): Promise<string> {
  // Take the first 100 and last 100 chars to create a simple fingerprint
  const simplified = (text.slice(0, 100) + text.slice(-100)).replace(/\s+/g, '');
  const encoder = new TextEncoder();
  const data = encoder.encode(simplified);
  const hashBuffer = await crypto.subtle.digest('SHA-1', data);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
}

// Process transcription with AI enhancement
async function processTranscriptionWithAI(text: string, preferredProcessor?: string): Promise<LogEntry[]> {
  try {
    // Handle preferred processor choice if specified
    if (preferredProcessor === 'rule-based') {
      console.log('User requested rule-based processing')
      return processTranscription(text)
    }
    
    // Try to enhance with AI
    try {
      // Use Gemini as default or if explicitly requested
      if (!preferredProcessor || preferredProcessor === 'gemini') {
        console.log('Attempting to process with Gemini AI...')
        const enhancedLogs = await enhanceLogsWithGemini(text)
        if (enhancedLogs && enhancedLogs.length > 0) {
          console.log(`Successfully generated ${enhancedLogs.length} logs with Gemini AI`)
          return enhancedLogs
        }
      }
      
      throw new Error('No logs generated by AI services')
    } catch (aiError) {
      console.error('AI service failed, using rule-based logs:', aiError)
      // Fallback to rule-based processing
      const ruleBasedLogs = await processTranscription(text)
      return ruleBasedLogs
    }
  } catch (error) {
    console.error('Fallback to simple processing due to error:', error)
    return processTranscription(text)
  }
}

// Enhance logs using Gemini AI with improved prompt engineering
async function enhanceLogsWithGemini(text: string): Promise<LogEntry[]> {
  const GEMINI_API_KEY = Deno.env.get('GEMINI_API_KEY')
  
  if (!GEMINI_API_KEY) {
    console.log('No Gemini API key found, using rule-based processing')
    throw new Error('Gemini API key not configured')
  }
  
  try {
    console.log('Calling Gemini API with enhanced prompt...')
    
    // Format the prompt for Gemini with more detailed instructions
    const prompt = `
    You are an expert industrial activity data processor. Analyze this industrial activity transcription and extract structured information:
    
    ${text}
    
    Extract the following details for each distinct activity mentioned in the transcription. Each paragraph likely represents a different activity or location, so analyze carefully.
    
    For EACH activity identified, provide:
    - Location: The specific site where the activity takes place (e.g., "Massey's Test Facility", "Sanchez Site", etc.)
    - Activity Category: Categorize as Installation, Maintenance, Monitoring, Construction, Transportation, Extraction, Processing, or another relevant category
    - Activity Type: The specific action being performed (be detailed and accurate)
    - Equipment: Any tools, machinery, or hardware mentioned
    - Personnel: The people or teams involved in the activity
    - Materials: Any substances, components, or resources being used or processed
    - Measurements: Any quantitative values mentioned (dimensions, weights, volumes, etc.)
    - Status: Determine if the activity is completed, in-progress, planned, delayed, or cancelled based on context
    - Notes: A concise summary of the activity (1-2 sentences maximum)
    
    Format your response ONLY as a valid JSON array with the following structure:
    [{
      "location": "string",
      "activityCategory": "string",
      "activityType": "string",
      "equipment": "string",
      "personnel": "string",
      "material": "string", 
      "measurement": "string",
      "status": "completed|in-progress|planned|delayed|cancelled",
      "notes": "string"
    }]
    
    Extract as many distinct activities as possible from the text. Make reasonable inferences when information is implied but not explicitly stated. DO NOT include any explanations or text outside the JSON array.
    `
    
    const response = await fetch('https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-goog-api-key': GEMINI_API_KEY,
      },
      body: JSON.stringify({
        contents: [
          {
            parts: [
              { text: prompt }
            ]
          }
        ],
        generationConfig: {
          temperature: 0.1, // Lower temperature for more consistent results
          topP: 0.8,
          topK: 40,
          maxOutputTokens: 8192,
        }
      })
    })
    
    const data = await response.json()
    
    if (!response.ok) {
      console.error('Gemini API error response:', data)
      throw new Error(`Gemini API error: ${data.error?.message || 'Unknown error'}`)
    }
    
    console.log('Gemini API response received, processing output...')
    
    // Extract the logs from the response
    if (data.candidates && data.candidates[0] && data.candidates[0].content) {
      const content = data.candidates[0].content
      const textParts = content.parts.filter(part => part.text).map(part => part.text)
      const responseText = textParts.join('')
      
      // Find the JSON part in the response
      const jsonMatch = responseText.match(/\[\s*\{[\s\S]*\}\s*\]/)
      if (jsonMatch) {
        const jsonStr = jsonMatch[0]
        console.log('Extracted JSON from Gemini response')
        
        try {
          const logsFromAI = JSON.parse(jsonStr)
          
          if (!Array.isArray(logsFromAI) || logsFromAI.length === 0) {
            console.error('Gemini returned invalid JSON or empty array')
            throw new Error('Invalid JSON structure from Gemini API')
          }
          
          // Process the AI-generated logs
          const enhancedLogs = logsFromAI.map((logItem, index) => {
            // Add missing fields or use defaults
            return {
              id: crypto.randomUUID(),
              timestamp: new Date().toISOString(),
              location: logItem.location || 'Unknown Location',
              activityCategory: logItem.activityCategory || 'Unspecified',
              activityType: logItem.activityType || `Activity ${index + 1}`,
              equipment: logItem.equipment || 'Unspecified Equipment',
              personnel: logItem.personnel || 'Unnamed Personnel',
              material: logItem.material || 'Unspecified Material',
              measurement: logItem.measurement || '',
              status: logItem.status || 'completed',
              notes: logItem.notes || '',
              referenceId: `REF-GEM-${Date.now().toString().slice(-5)}-${index}`,
              // Add location coordinates for map visualization
              coordinates: getRandomCoordinatesForLocation(logItem.location)
            }
          })
          
          console.log('Enhanced logs with AI:', enhancedLogs.length, 'entries')
          return enhancedLogs
        } catch (jsonError) {
          console.error('Error parsing JSON from Gemini:', jsonError)
          throw new Error('Failed to parse Gemini response JSON')
        }
      } else {
        console.error('Could not find JSON in Gemini response')
        throw new Error('No valid JSON found in Gemini response')
      }
    }
    
    throw new Error('Could not parse Gemini response')
  } catch (error) {
    console.error('Error calling Gemini API:', error)
    throw error
  }
}

// Helper function to generate realistic coordinates for locations
function getRandomCoordinatesForLocation(location: string): [number, number] {
  // SpaceX Starbase area in Boca Chica, TX as the default base coordinates
  const baseCoordinates: Record<string, [number, number]> = {
    "Massey's Test Facility": [-97.1722, 25.9969],
    "Sanchez Site": [-97.1822, 25.9869],
    "Launch Site": [-97.1522, 26.0069],
    "Build Site": [-97.1622, 25.9769],
    "Star Factory": [-97.1922, 25.9569],
    "Tank Farm": [-97.1422, 25.9669],
    "Launch Mount": [-97.1322, 25.9769],
    "Landing Pad": [-97.1222, 25.9869],
    "Mega Bay": [-97.2022, 25.9969],
    "Highway 4": [-97.1822, 25.9469],
    "Fluids Bunker": [-97.1722, 26.0169],
    "Rio West": [-97.2122, 25.9269],
  };
  
  // Extract location name, handling partial matches
  let bestMatch = "Unknown Location";
  let longestMatch = 0;
  
  // Check for the location in our known coordinates
  for (const knownLocation of Object.keys(baseCoordinates)) {
    if (location.includes(knownLocation) && knownLocation.length > longestMatch) {
      bestMatch = knownLocation;
      longestMatch = knownLocation.length;
    }
  }
  
  // If location is in our predefined list, use those coordinates with a slight random offset
  if (bestMatch !== "Unknown Location") {
    const [lng, lat] = baseCoordinates[bestMatch];
    // Add small random offset (up to ~100m)
    return [
      lng + (Math.random() - 0.5) * 0.003,
      lat + (Math.random() - 0.5) * 0.003
    ];
  }
  
  // For unknown locations, generate coordinates in the general Starbase area
  return [
    -97.1722 + (Math.random() - 0.5) * 0.05,  // Starbase longitude with random offset
    25.9969 + (Math.random() - 0.5) * 0.05    // Starbase latitude with random offset
  ];
}

// Improved rule-based processing as fallback with SpaceX Starbase specific terms
async function processTranscription(text: string): Promise<LogEntry[]> {
  const logs: LogEntry[] = [];
  
  // Split text into paragraphs
  const paragraphs = text.split(/\n\n|\r\n\r\n|\.\s+(?=[A-Z])/).filter(p => p.trim().length > 20);
  
  // SpaceX Starbase specific locations
  const possibleLocations = [
    "Massey's Test Facility", "Masses Test Facility", "Masses", "Massey's", 
    "Sanchez Site", "Sanchez", "Launch Site", "Build Site", 
    "Star Factory", "Tank Farm", "Launch Mount", "Landing Pad",
    "Mega Bay", "Highway 4", "Fluids Bunker", "Rio West"
  ];
  
  // SpaceX Starbase related activities
  const activityCategories = {
    "Installation": ["install", "mounting", "placement", "setup", "fitting", "position"],
    "Maintenance": ["maintain", "repair", "service", "check", "inspect", "overhaul"],
    "Monitoring": ["monitor", "measure", "record", "analyze", "test", "observe"],
    "Construction": ["construct", "build", "assemble", "develop", "pour", "excavate"],
    "Transportation": ["transport", "move", "ship", "deliver", "relocate", "roll out"],
    "Removal": ["remove", "dismantle", "demolish", "take down", "scrap"],
    "Testing": ["test", "cryo test", "static fire", "proof test", "validate"],
    "Manufacturing": ["manufacture", "fabricate", "produce", "weld", "mill"]
  };
  
  // SpaceX Starbase specific equipment and components
  const equipmentTypes = [
    "Booster", "Ship", "Starship", "Raptor Engine", "Super Heavy", 
    "Quick Disconnect", "Launch Mount", "Chopsticks", "SPMT", 
    "Bridge Crane", "Lift Points", "Hydraulic Ram", "Load Cell", 
    "Test Stand", "Cryostand", "Deluge System", "Transport Stand",
    "Clamp", "Tank", "Pipe", "Excavator", "Crane", "Scaffolding"
  ];
  
  // SpaceX Starbase specific materials
  const materialTypes = [
    "Stainless Steel", "Liquid Oxygen", "Liquid Methane", "LOX", "LCH4", 
    "Nitrogen", "Concrete", "Water", "Rebar", "Steel", "Plumbing", 
    "Conduit", "Insulation", "Flanges", "Cabling", "Sheet Metal"
  ];
  
  // Process each paragraph to extract information
  for (let i = 0; i < paragraphs.length; i++) {
    const paragraph = paragraphs[i];
    
    try {
      // Extract location - search for SpaceX Starbase specific locations
      let location = "Unknown Location";
      const locationMatches = [];
      
      for (const loc of possibleLocations) {
        if (paragraph.includes(loc)) {
          locationMatches.push(loc);
        }
      }
      
      // Use the longest matching location name
      if (locationMatches.length > 0) {
        location = locationMatches.reduce((prev, current) => 
          (current.length > prev.length) ? current : prev
        );
      }
      
      // Extract activity category and type
      let activityCategory = "Unspecified";
      let activityType = "";
      
      const activityMatches = [];
      
      for (const [category, keywords] of Object.entries(activityCategories)) {
        for (const keyword of keywords) {
          if (paragraph.toLowerCase().includes(keyword)) {
            activityMatches.push({
              category,
              keyword,
              index: paragraph.toLowerCase().indexOf(keyword)
            });
          }
        }
      }
      
      // Use the earliest occurring activity in the paragraph
      if (activityMatches.length > 0) {
        activityMatches.sort((a, b) => a.index - b.index);
        const firstMatch = activityMatches[0];
        activityCategory = firstMatch.category;
        
        // Try to extract a specific activity type using surrounding words
        const regex = new RegExp(`\\b${firstMatch.keyword}\\w*\\b(?:\\s+\\w+){0,3}`, 'i');
        const match = paragraph.match(regex);
        if (match) {
          activityType = match[0].trim();
        } else {
          activityType = firstMatch.keyword.charAt(0).toUpperCase() + firstMatch.keyword.slice(1);
        }
      }
      
      // If we couldn't determine activity type, extract relevant phrases
      if (!activityType) {
        // Try to find verb phrases
        const verbPhraseRegex = /\b(installing|building|testing|moving|preparing|continuing|completed|working on|adding)\b\s+([^\.,;]{3,30})/i;
        const verbMatch = paragraph.match(verbPhraseRegex);
        
        if (verbMatch) {
          activityType = verbMatch[0].trim();
          
          // Map to appropriate category
          const verb = verbMatch[1].toLowerCase();
          if (verb.includes("install") || verb.includes("adding")) {
            activityCategory = "Installation";
          } else if (verb.includes("build") || verb.includes("prepar")) {
            activityCategory = "Construction";
          } else if (verb.includes("test")) {
            activityCategory = "Testing";
          } else if (verb.includes("mov")) {
            activityCategory = "Transportation";
          }
        } else {
          // Use the first sentence or part as fallback
          const firstSentence = paragraph.split('.')[0];
          if (firstSentence.length > 10 && firstSentence.length < 100) {
            activityType = firstSentence.trim();
          } else {
            activityType = "Activity " + (i + 1);
          }
        }
      }
      
      // Extract equipment - find SpaceX specific equipment mentions
      let equipment = "Unspecified Equipment";
      const equipmentMatches = [];
      
      for (const equipType of equipmentTypes) {
        const equipRegex = new RegExp(`\\b${equipType.replace(/\s+/g, '\\s+')}s?\\b`, 'i');
        const matches = paragraph.match(equipRegex);
        if (matches) {
          equipmentMatches.push(matches[0]);
        }
      }
      
      if (equipmentMatches.length > 0) {
        // Take the first mentioned equipment
        equipment = equipmentMatches[0];
      } else {
        // Look for numbered equipment like "Booster 16" or "Ship 35"
        const numberedEquipRegex = /\b(Booster|Ship|Engine|Raptor|Mega ?Bay)\s+\d+\b/gi;
        const numberedMatches = paragraph.match(numberedEquipRegex);
        if (numberedMatches && numberedMatches.length > 0) {
          equipment = numberedMatches[0];
        }
      }
      
      // Extract material - find SpaceX specific materials
      let material = "Unspecified Material";
      const materialMatches = [];
      
      for (const matType of materialTypes) {
        const matRegex = new RegExp(`\\b${matType.replace(/\s+/g, '\\s+')}\\b`, 'i');
        const matches = paragraph.match(matRegex);
        if (matches) {
          materialMatches.push(matches[0]);
        }
      }
      
      if (materialMatches.length > 0) {
        material = materialMatches[0];
      }
      
      // Extract measurement if present (looking for numbers with units)
      let measurement = "";
      const measurementRegex = /\b\d+(\.\d+)?\s*(meters|m|km|kg|tons|ft|feet|inches|hours|days|truckloads)\b/i;
      const measureMatch = paragraph.match(measurementRegex);
      if (measureMatch) {
        measurement = measureMatch[0];
      } else {
        // Look for percentages, quantities, or other measurements
        const altMeasureRegex = /\b(\d+(\.\d+)?%|\d+(\.\d+)?\s*trucks|\d+(\.\d+)?\s*tanks|\d+\s*pump)/i;
        const altMatch = paragraph.match(altMeasureRegex);
        if (altMatch) {
          measurement = altMatch[0];
        }
      }
      
      // Detect dates from SpaceX format (March 15th)
      let timestamp = new Date().toISOString();
      const dateRegex = /\b(January|February|March|April|May|June|July|August|September|October|November|December|Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+\d{1,2}(st|nd|rd|th)?\b/i;
      const dateMatch = paragraph.match(dateRegex);
      if (dateMatch) {
        const currentYear = new Date().getFullYear();
        const dateStr = `${dateMatch[0]}, ${currentYear}`;
        const date = new Date(dateStr);
        if (!isNaN(date.getTime())) {
          timestamp = date.toISOString();
        }
      }
      
      // Personnel - inferring from SpaceX context
      let personnel = "Unnamed Personnel";
      const personnelRegex = /\b(crews?|workers?|teams?|engineers?|technicians?|SpaceX)\b/i;
      const personnelMatch = paragraph.match(personnelRegex);
      if (personnelMatch) {
        personnel = personnelMatch[0];
      }
      
      // Determine status with improved detection
      let status: "completed" | "in-progress" | "planned" | "delayed" | "cancelled" = "completed";
      
      // Detect in-progress
      if (paragraph.match(/\b(continuing|ongoing|in progress|being|currently|still|working on)\b/i)) {
        status = "in-progress";
      } 
      // Detect planned activities
      else if (paragraph.match(/\b(will|scheduled|plan(ned)?|expect(ed)?|upcoming|soon|future)\b/i)) {
        status = "planned";
      } 
      // Detect completed activities
      else if (paragraph.match(/\b(completed|finished|done|installed|removed|built)\b/i)) {
        status = "completed";
      }
      // Detect delayed activities
      else if (paragraph.match(/\b(delay(ed)?|postpone(d)?|reschedule(d)?|waiting)\b/i)) {
        status = "delayed";
      }
      // Detect cancelled activities
      else if (paragraph.match(/\b(cancel(led)?|abort(ed)?|scrapped?)\b/i)) {
        status = "cancelled";
      }

      // Generate coordinates for map visualization
      const coordinates: [number, number] = getRandomCoordinatesForLocation(location);
      
      // Generate a reference ID based on location
      const locationAbbr = location.split(' ')[0].slice(0, 3).toUpperCase();
      
      // Generate a log entry
      logs.push({
        id: crypto.randomUUID(),
        timestamp,
        location,
        activityCategory,
        activityType,
        equipment,
        personnel,
        material,
        measurement,
        status,
        notes: paragraph.length > 300 ? paragraph.slice(0, 297) + '...' : paragraph,
        referenceId: `${locationAbbr}-${Date.now().toString().slice(-5)}-${i}`,
        coordinates
      });
    } catch (error) {
      console.error("Error processing paragraph:", error);
      // Skip this paragraph if processing fails
    }
  }
  
  return logs;
}
